<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Camera Live Preview</title>
    <link href="{{ url_for('static', filename='SpaceGrotesk.css') }}" rel="stylesheet" />
    <script src="{{ url_for('static', filename='tailwindcss.js') }}"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        display: ["Space Grotesk", "sans-serif"],
                    },
                    colors: {
                        midnight: "#050b1a",
                        aurora: "#7cf5ff",
                        ember: "#FCB300",
                        slateglass: "rgba(15, 23, 42, 0.7)",
                    },
                    boxShadow: {
                        glow: "0 20px 60px rgba(8, 255, 214, 0.35)",
                    },
                    fontSize: {
                        xxs: "0.625rem",
                    },
                },
            },
        };
    </script>
    <style>
        #capture-button.timelapse-ring::after {
            content: "";
            position: absolute;
            inset: -7px;
            border: 4px dotted rgba(255, 255, 255, 0.4);
            border-radius: 9999px;
            pointer-events: none;
            transition: border 100ms ease;
        }

        #capture-button.timelapse-ring:hover::after {
            border: 4px dotted rgba(255, 255, 255, 0.6);
        }
    </style>
</head>

<body class="min-h-screen bg-black text-slate-100 font-display relative overflow-hidden">
    <div class="hidden pointer-events-none absolute inset-0">
        <div
            class="absolute -top-32 right-10 h-72 w-72 rounded-full bg-gradient-to-b from-aurora/50 to-aurora/80 blur-3xl opacity-70">
        </div>
    </div>
    <header class="relative z-10 flex max-w-full flex-col items-center gap-4 px-6 pt-5 lg:px-12">
        <div class="flex justify-center">
            <div id="status-container" class="flex items-center gap-2 px-4 py-2 backdrop-blur">
                <span id="status-indicator" class="animate-pulse"><svg xmlns="http://www.w3.org/2000/svg" height="24px"
                        viewBox="0 -960 960 960" width="24px" fill="currentColor">
                        <path
                            d="M152-160q-23 0-35-20.5t1-40.5l328-525q12-19 34-19t34 19l328 525q13 20 1 40.5T808-160H152Zm72-80h512L480-650 224-240Zm256-205Z" />
                    </svg></span>
                <span id="status" class="text-sm uppercase tracking-wide">Connecting...</span>
            </div>
        </div>
    </header>
    <main class="relative z-10 flex flex-col items-center lg:flex-row lg:items-stretch lg:px-5 lg:py-6 gap-8">
        <section class="max-w-6xl w-full h-full justify-center items-center flex flex-col mx-auto">
            <figure
                class="w-full h-full min-h-[350px] md:mt-0 mt-12 md:rounded-2xl overflow-hidden justify-center items-center">
                <div class="relative">
                    <div class="absolute inset-0 grid place-items-center pointer-events-none">
                        <div id="capture-progress" class="hidden z-20 flex flex-col items-center gap-3">
                            <span class="h-8 w-8 border-2 border-slate-300 border-t-transparent rounded-full animate-spin"></span>
                            <p class="text-sm text-center text-slate-300">Capture in progress...</p>
                        </div>
                    </div>
                    <img id="stream-preview-img" class="w-full h-full object-fit transition-blur transition duration-150" src="{{ stream_url }}" alt="Live camera feed" />
                </div>
            </figure>
            <div id="capture-controls"
                class="fixed bottom-10 left-1/2 -translate-x-1/2 w-full md:max-w-[40vw] bg-black pt-4 px-4 transform">
                <div id="secondary-controls" class="px-4">
                    <div id="mode-controls-grid" class="grid w-full grid-cols-1 gap-6 md:grid-cols-2"
                        data-visible-modes="auto,manual">

                        <div class="flex flex-col items-center gap-2 text-center rounded-full md:items-start md:text-left"
                            data-visible-modes="auto">
                            <label for="capture-profile"
                                class="w-full text-xxs uppercase tracking-[0.3em] text-slate-400 text-center">Trigger
                                Object</label>
                            <div class="relative inline-flex w-full max-w-sm">
                                <select id="capture-profile"
                                    class="appearance-none w-full min-w-[100px] rounded-full border border-white/10 bg-slateglass px-6 py-3 pr-10 text-sm font-medium tracking-wide text-slate-100 focus:outline-none focus:ring-2 focus:ring-aurora/60">
                                    <!--Populate with options dynamically. Loaded from /api/labels-->
                                </select>
                                <span
                                    class="pointer-events-none absolute inset-y-0 right-4 flex items-center justify-center text-slate-400">
                                    &#9662;
                                </span>
                            </div>
                        </div>


                        <div class="flex flex-col items-center gap-2 text-center rounded-full md:items-start md:text-left"
                            data-visible-modes="auto,manual">
                            <label
                                class="w-full text-xxs uppercase tracking-[0.3em] text-slate-400 text-center">Mode</label>
                            <div id="mode-selector-row"
                                class="flex w-full flex-row items-center justify-center rounded-full gap-3 overflow-x-auto flex-nowrap md:justify-start">
                                <nav
                                    class="inline-flex shrink-0 justify-center gap-1 rounded-full border border-white/10 px-1 py-1 my-1 mx-1">
                                    <button type="button" data-shoot-mode="single"
                                        class="rounded-full bg-white/10 px-5 py-2 text-sm font-medium tracking-wide text-white shadow-glow">
                                        I
                                    </button>
                                    <button type="button" data-shoot-mode="burst"
                                        class="rounded-full px-5 py-2 text-sm font-medium tracking-wide text-slate-300 transition hover:text-white">
                                        III
                                    </button>
                                </nav>
                                <div class="flex shrink-0 flex-col items-center gap-2">
                                    <div class="relative inline-flex w-full">
                                        <select id="burst-count"
                                            class="appearance-none w-full rounded-full border border-white/10 bg-slateglass px-6 py-3 pr-10 text-sm font-medium tracking-wide text-slate-100 focus:outline-none focus:ring-2 focus:ring-aurora/60 opacity-50 cursor-not-allowed"
                                            disabled>
                                            <option value="2">2</option>
                                            <option value="3">3</option>
                                            <option value="4">4</option>
                                            <option value="5">5</option>
                                            <option value="6">6</option>
                                            <option value="7">7</option>
                                            <option value="8">8</option>
                                            <option value="9">9</option>
                                            <option value="10">10</option>
                                        </select>
                                        <span
                                            class="pointer-events-none absolute inset-y-0 right-4 flex items-center justify-center text-slate-400">
                                            &#9662;
                                        </span>
                                    </div>
                                </div>
                            </div>

                        </div>

                    </div>

                    <div class="w-full max-w-3xl space-y-4 hidden" data-visible-modes="timelapse">
                        <div class="grid gap-4 grid-cols-2">
                            <div class="flex flex-col gap-2 text-center md:text-left">
                                <label for="timelapse-interval"
                                    class="text-xxs uppercase tracking-[0.3em] text-slate-400">Interval</label>
                                <div class="relative inline-flex w-full">
                                    <select id="timelapse-interval"
                                        class="appearance-none w-full rounded-full border border-white/10 bg-slateglass px-6 py-3 pr-10 text-sm font-medium tracking-wide text-slate-100 focus:outline-none focus:ring-2 focus:ring-aurora/60">
                                        <option value="5">5s</option>
                                        <option value="10">10s</option>
                                        <option value="30" selected>30s</option>
                                        <option value="60">1m</option>
                                        <option value="120">2m</option>
                                        <option value="300">5m</option>
                                    </select>
                                    <span
                                        class="pointer-events-none absolute inset-y-0 right-4 flex items-center justify-center text-slate-400">&#9662;</span>
                                </div>
                            </div>
                            <div class="flex flex-col gap-2 text-center md:text-left">
                                <label for="timelapse-duration"
                                    class="text-xxs uppercase tracking-[0.3em] text-slate-400">Total
                                    Runtime</label>
                                <div class="relative inline-flex w-full">
                                    <select id="timelapse-duration"
                                        class="appearance-none w-full rounded-full border border-white/10 bg-slateglass px-6 py-3 pr-10 text-sm font-medium tracking-wide text-slate-100 focus:outline-none focus:ring-2 focus:ring-aurora/60">
                                        <option value="60">1 minute</option>
                                        <option value="300">5 minutes</option>
                                        <option value="600" selected>10 minutes</option>
                                        <option value="1800">30 minutes</option>
                                        <option value="3600">1 hour</option>
                                        <option value="7200">2 hours</option>
                                    </select>
                                    <span
                                        class="pointer-events-none absolute inset-y-0 right-4 flex items-center justify-center text-slate-400">&#9662;</span>
                                </div>
                            </div>
                        </div>
                        <div class="px-5 pt-4 text-center md:text-left">
                            <p id="timelapse-summary"
                                class="text-xxs uppercase tracking-[0.3em] text-aurora hidden text-center">
                            </p>
                            <p id="timelapse-status" class="hidden mt-4 text-sm text-slate-400">
                                Press to start recording
                            </p>
                        </div>
                    </div>
                </div>
                <div class="flex flex-col items-center gap-4 w-full my-6">
                    <div class="w-full max-w-[300px]">
                        <div class="grid grid-cols-[1fr_auto_1fr] items-center gap-4">

                            <div class="col-start-1 flex justify-start">
                                <a href="{{ url_for('gallery') }}"
                                    class="group inline-flex items-center gap-3 rounded-2xl text-left text-xs uppercase tracking-[0.3em] text-slate-300 transition hover:border-white/30 hover:bg-white/5 focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
                                    aria-label="Open gallery">
                                    <div
                                        class="relative h-14 w-14 overflow-hidden rounded-2xl border border-white/10 bg-white/5">
                                        {% if latest_capture %}
                                        <img src="{{ url_for('serve_preview', filename=latest_capture.cover_path) }}"
                                            alt="Latest capture from {{ latest_capture.timestamp_label }}"
                                            class="h-full w-full object-cover transition duration-300 group-hover:scale-105" />
                                        {% else %}
                                        <div
                                            class="flex h-full w-full items-center justify-center text-[10px] font-medium tracking-[0.4em] text-slate-500">

                                        </div>
                                        {% endif %}
                                        <span
                                            class="pointer-events-none absolute inset-0 rounded-2xl bg-gradient-to-t from-black/60 via-black/10 to-transparent"></span>
                                    </div>
                                </a>
                            </div>

                            <div class="col-start-2 flex justify-center items-center">
                                <button id="capture-button" type="button"
                                    class="relative h-16 w-16 rounded-full bg-ember text-white shadow-glow transition hover:bg-ember/90 flex items-center justify-center hover:ring-8 ring-4 ring-white/40"
                                    aria-pressed="false" aria-label="Primary capture action">
                                    <span id="capture-indicator"
                                        class="h-6 w-6 rounded-md bg-ember opacity-0 scale-75 transition-all duration-150 ease-out"
                                        aria-hidden="true"></span>
                                    <span class="sr-only">Enable auto capture</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex justify-center">
                    <nav
                        class="inline-flex justify-center gap-1 rounded-full border border-white/10 bg-slateglass px-1 py-1 backdrop-blur">
                        <button type="button" data-ui-mode="auto"
                            class="rounded-full bg-white/10 px-5 py-2 text-sm font-medium tracking-wide text-white shadow-glow">
                            Auto
                        </button>
                        <button type="button" data-ui-mode="manual"
                            class="rounded-full px-5 py-2 text-sm font-medium tracking-wide text-slate-300 transition hover:text-white">
                            Manual
                        </button>
                        <button type="button" data-ui-mode="timelapse"
                            class="rounded-full px-5 py-2 text-sm font-medium tracking-wide text-slate-300 transition hover:text-white">
                            Timelapse
                        </button>
                    </nav>
                </div>
            </div>
        </section>

    </main>
    <script>
        const LABELS_URL = "{{ labels_url }}";
        const CAPTURE_MODE_URL = "{{ capture_mode_url }}";
        const CAPTURE_LABEL_URL = "{{ capture_label_url }}";
        const CAPTURE_SETTINGS_URL = "{{ capture_settings_url }}";
        const UI_MODE_URL = "{{ ui_mode_url }}";
        const MANUAL_CAPTURE_URL = "{{ manual_capture_url }}";
        const TIMELAPSE_URL = "{{ timelapse_url }}";
        const MODE_AUTO = "auto";
        const MODE_MANUAL = "manual";
        const MODE_TIMELAPSE = "timelapse";
        const AVAILABLE_MODES = [MODE_AUTO, MODE_MANUAL, MODE_TIMELAPSE];
        const captureSelect = document.getElementById("capture-profile");
        const captureButton = document.getElementById("capture-button");
        const captureIndicator = document.getElementById("capture-indicator");
        const shootModeButtons = document.querySelectorAll("[data-shoot-mode]");
        const burstCountSelect = document.getElementById("burst-count");
        const modeButtons = document.querySelectorAll("[data-ui-mode]");
        const modeVisibilityTargets = document.querySelectorAll("[data-visible-modes]");
        const modeControlsGrid = document.getElementById("mode-controls-grid");
        const modeSelectorRow = document.getElementById("mode-selector-row");
        const timelapseIntervalSelect = document.getElementById("timelapse-interval");
        const timelapseDurationSelect = document.getElementById("timelapse-duration");
        const timelapseStatusEl = document.getElementById("timelapse-status");
        const timelapseSummaryEl = document.getElementById("timelapse-summary");
        const DEFAULT_CAPTURE_LABEL = "Bird";
        const DEFAULT_SHOOT_MODE = "burst";
        const DEFAULT_BURST_COUNT = 5;
        const DEFAULT_TIMELAPSE_INTERVAL = 30;
        const DEFAULT_TIMELAPSE_DURATION = 600;
        let captureModeEnabled = false;
        let shootMode = DEFAULT_SHOOT_MODE;
        let burstImageCount = DEFAULT_BURST_COUNT;
        let activeMode = MODE_AUTO;
        let manualCaptureInFlight = false;
        let timelapseActive = false;
        let timelapseRequestInFlight = false;
        let timelapseIntervalSeconds = Number(timelapseIntervalSelect?.value ?? DEFAULT_TIMELAPSE_INTERVAL);
        let timelapseDurationSeconds = Number(timelapseDurationSelect?.value ?? DEFAULT_TIMELAPSE_DURATION);
        let timelapseCompletedCaptures = 0;
        let timelapsePlannedCaptures = 0;
        let timelapseStatusPollHandle = null;

        if (burstCountSelect) {
            burstCountSelect.value = DEFAULT_BURST_COUNT.toString();
        }
        if (timelapseIntervalSelect && !timelapseIntervalSelect.value) {
            timelapseIntervalSelect.value = DEFAULT_TIMELAPSE_INTERVAL.toString();
        }
        if (timelapseDurationSelect && !timelapseDurationSelect.value) {
            timelapseDurationSelect.value = DEFAULT_TIMELAPSE_DURATION.toString();
        }

        function updateCaptureButtonUI() {
            if (!captureButton) return;
            const isAutoMode = activeMode === MODE_AUTO;
            const isTimelapseMode = activeMode === MODE_TIMELAPSE;
            const isManualMode = activeMode === MODE_MANUAL;
            const showActiveState = (isAutoMode && captureModeEnabled) || (isTimelapseMode && timelapseActive);
            const disableButton = (isManualMode && manualCaptureInFlight) || (isTimelapseMode && timelapseRequestInFlight);
            const allowPrimaryHover = !showActiveState && !disableButton;

            captureButton.classList.toggle("bg-transparent", showActiveState);
            captureButton.classList.toggle("bg-ember", !showActiveState);
            captureButton.classList.toggle("hover:bg-white/10", showActiveState && !isTimelapseMode);
            captureButton.classList.toggle("hover:bg-ember/90", allowPrimaryHover);
            captureButton.classList.toggle("cursor-not-allowed", disableButton);
            captureButton.toggleAttribute("disabled", disableButton);
            captureButton.setAttribute("aria-pressed", showActiveState.toString());
            captureButton.classList.toggle("timelapse-ring", isTimelapseMode);
            captureButton.classList.toggle("hover:ring-8", !isTimelapseMode);
            captureButton.classList.toggle("ring-4", !isTimelapseMode);
            captureButton.classList.toggle("ring-white/40", !isTimelapseMode);

            if (captureIndicator) {
                captureIndicator.classList.toggle("opacity-0", !showActiveState);
                captureIndicator.classList.toggle("scale-75", !showActiveState);
                captureIndicator.classList.toggle("opacity-100", showActiveState);
                captureIndicator.classList.toggle("scale-100", showActiveState);
            }

            const srText = captureButton.querySelector(".sr-only");
            if (srText) {
                if (isAutoMode) {
                    srText.textContent = captureModeEnabled ? "Disable auto capture" : "Enable auto capture";
                } else if (isManualMode) {
                    srText.textContent = manualCaptureInFlight ? "Capturing..." : "Trigger manual capture";
                } else if (isTimelapseMode) {
                    if (timelapseRequestInFlight) {
                        srText.textContent = "Updating timelapse schedule";
                    } else {
                        srText.textContent = timelapseActive ? "Stop timelapse" : "Start timelapse";
                    }
                }
            }
        }
        updateCaptureButtonUI();

        function computePlannedTimelapseCaptures() {
            if (timelapseIntervalSeconds <= 0 || timelapseDurationSeconds <= 0) {
                return 0;
            }
            return Math.max(1, Math.floor(timelapseDurationSeconds / timelapseIntervalSeconds) + 1);
        }

        function formatSecondsCompact(seconds) {
            if (!Number.isFinite(seconds) || seconds <= 0) {
                return "0s";
            }
            if (seconds < 60) {
                return `${Math.round(seconds)}s`;
            }
            const minutes = seconds / 60;
            if (minutes < 60) {
                return `${Math.round(minutes)}m`;
            }
            const hours = minutes / 60;
            if (hours < 24) {
                const roundedHours = Math.round(hours * 10) / 10;
                return `${roundedHours}h`;
            }
            const days = hours / 24;
            return `${Math.round(days * 10) / 10}d`;
        }

        function updateTimelapseInputsState(disableControls) {
            [timelapseIntervalSelect, timelapseDurationSelect].forEach((select) => {
                if (!select) return;
                select.disabled = disableControls;
                select.classList.toggle("opacity-50", disableControls);
                select.classList.toggle("cursor-not-allowed", disableControls);
                select.setAttribute("aria-disabled", disableControls.toString());
            });
        }

        function updateTimelapseUI() {
            const disableControls = timelapseRequestInFlight || timelapseActive;
            updateTimelapseInputsState(disableControls);
            const planned = timelapseActive
                ? timelapsePlannedCaptures || computePlannedTimelapseCaptures()
                : computePlannedTimelapseCaptures();
            if (timelapseSummaryEl) {
                if (planned > 0) {
                    const cadenceLabel = `${formatSecondsCompact(timelapseIntervalSeconds)} interval`;
                    const durationLabel = `${formatSecondsCompact(timelapseDurationSeconds)} runtime`;
                    timelapseSummaryEl.textContent = `${planned} frames • ${cadenceLabel} • ${durationLabel}`;
                    timelapseSummaryEl.classList.remove("hidden");
                } else {
                    timelapseSummaryEl.classList.add("hidden");
                }
            }
            if (timelapseStatusEl) {
                if (timelapseRequestInFlight) {
                    timelapseStatusEl.textContent = "Loading...";
                } else if (timelapseActive) {
                    const completedLabel = `${Math.min(timelapseCompletedCaptures, planned)}/${planned}`;
                    timelapseStatusEl.textContent = `Running | ${completedLabel} frames captured.`;
                } else {
                    timelapseStatusEl.textContent = "Press to start recording";
                }
            }
            timelapsePlannedCaptures = planned;
            updateCaptureButtonUI();
        }
        updateTimelapseUI();

        async function fetchCaptureMode() {
            try {
                const response = await fetch(CAPTURE_MODE_URL);
                const data = await response.json();
                captureModeEnabled = Boolean(data.enabled);
            } catch (error) {
                captureModeEnabled = false;
                console.error("Unable to fetch capture mode", error);
            } finally {
                updateCaptureButtonUI();
            }
        }

        async function setCaptureMode(enabled) {
            if (!CAPTURE_MODE_URL || activeMode !== MODE_AUTO) {
                captureModeEnabled = false;
                updateCaptureButtonUI();
                return;
            }
            try {
                const response = await fetch(CAPTURE_MODE_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ enabled }),
                });
                if (!response.ok) throw new Error("Failed to update capture mode");
                const data = await response.json();
                captureModeEnabled = Boolean(data.enabled);
            } catch (error) {
                console.error("Unable to update capture mode", error);
                captureModeEnabled = false;
            } finally {
                updateCaptureButtonUI();
            }
        }

        async function toggleCaptureMode() {
            if (activeMode !== MODE_AUTO) return;
            await setCaptureMode(!captureModeEnabled);
        }

        function updateShootControlsUI() {
            shootModeButtons.forEach((button) => {
                const isActive = button.dataset.shootMode === shootMode;
                button.classList.toggle("bg-white/10", isActive);
                button.classList.toggle("text-white", isActive);
                button.classList.toggle("shadow-glow", isActive);
                button.classList.toggle("text-slate-300", !isActive);
            });

            if (burstCountSelect) {
                const disableBurst = shootMode === "single";
                burstCountSelect.disabled = disableBurst;
                burstCountSelect.classList.toggle("opacity-50", disableBurst);
                burstCountSelect.classList.toggle("cursor-not-allowed", disableBurst);
                burstCountSelect.setAttribute("aria-disabled", disableBurst.toString());
                if (!disableBurst) {
                    burstCountSelect.value = burstImageCount.toString();
                }
            }
        }

        function updateModeVisibility() {
            modeVisibilityTargets.forEach((element) => {
                const allowedModes = (element.dataset.visibleModes || "")
                    .split(",")
                    .map((mode) => mode.trim().toLowerCase())
                    .filter(Boolean);
                if (allowedModes.length === 0) {
                    return;
                }
                element.classList.toggle("hidden", !allowedModes.includes(activeMode));
            });

            if (modeControlsGrid) {
                const visibleChildren = Array.from(modeControlsGrid.children).filter(
                    (child) => !child.classList.contains("hidden")
                );
                const singleVisible = visibleChildren.length <= 1;
                modeControlsGrid.classList.toggle("md:grid-cols-1", singleVisible);
                modeControlsGrid.classList.toggle("md:grid-cols-2", !singleVisible);
                modeControlsGrid.classList.toggle("md:justify-items-center", singleVisible);
                if (modeSelectorRow) {
                    modeSelectorRow.classList.toggle("md:justify-center", singleVisible);
                    modeSelectorRow.classList.toggle("md:justify-start", !singleVisible);
                }
            }
        }

        function updateModeTabs() {
            modeButtons.forEach((button) => {
                const targetMode = (button.dataset.uiMode || "").toLowerCase();
                const isActive = targetMode === activeMode;
                button.classList.toggle("bg-white/10", isActive);
                button.classList.toggle("text-white", isActive);
                button.classList.toggle("shadow-glow", isActive);
                button.classList.toggle("text-slate-300", !isActive);
            });
        }

        function updateModeUI() {
            updateModeTabs();
            updateModeVisibility();
            updateCaptureButtonUI();
            updateTimelapseUI();
        }

        function persistCaptureSettings(overrides = {}) {
            if (!CAPTURE_SETTINGS_URL) return Promise.resolve();
            const payload = {
                mode: overrides.mode ?? shootMode,
                burst_count: overrides.burst_count ?? burstImageCount,
            };
            return fetch(CAPTURE_SETTINGS_URL, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            }).catch((error) => {
                console.error("Unable to save capture settings", error);
            });
        }

        function applyTimelapseStatus(data = {}) {
            if (!data || typeof data !== "object") {
                return;
            }
            if (typeof data.interval_seconds === "number" && !Number.isNaN(data.interval_seconds)) {
                timelapseIntervalSeconds = Number(data.interval_seconds);
                if (timelapseIntervalSelect) {
                    timelapseIntervalSelect.value = timelapseIntervalSeconds.toString();
                }
            }
            if (typeof data.duration_seconds === "number" && !Number.isNaN(data.duration_seconds)) {
                timelapseDurationSeconds = Number(data.duration_seconds);
                if (timelapseDurationSelect) {
                    timelapseDurationSelect.value = timelapseDurationSeconds.toString();
                }
            }
            if (typeof data.captures_completed === "number") {
                timelapseCompletedCaptures = Number(data.captures_completed);
            }
            if (typeof data.planned_captures === "number") {
                timelapsePlannedCaptures = Number(data.planned_captures);
            }
            timelapseActive = Boolean(data.active);
            updateTimelapseUI();
        }

        function scheduleTimelapseStatusPoll(delayMs = 6000) {
            if (timelapseStatusPollHandle) {
                clearTimeout(timelapseStatusPollHandle);
                timelapseStatusPollHandle = null;
            }
            if (!TIMELAPSE_URL) {
                return;
            }
            const shouldPoll = timelapseActive || activeMode === MODE_TIMELAPSE;
            if (!shouldPoll) {
                return;
            }
            timelapseStatusPollHandle = window.setTimeout(() => {
                void fetchTimelapseStatus();
            }, Math.max(1000, delayMs));
        }

        async function fetchTimelapseStatus() {
            if (!TIMELAPSE_URL) {
                updateTimelapseUI();
                return;
            }
            try {
                const response = await fetch(TIMELAPSE_URL);
                if (!response.ok) throw new Error("Failed to load timelapse status");
                const data = await response.json();
                applyTimelapseStatus(data);
            } catch (error) {
                console.error("Unable to load timelapse status", error);
            } finally {
                scheduleTimelapseStatusPoll(timelapseActive ? 4000 : 10000);
            }
        }

        async function startTimelapse() {
            if (!TIMELAPSE_URL || timelapseRequestInFlight) {
                return;
            }
            timelapseRequestInFlight = true;
            updateTimelapseUI();
            try {
                const payload = {
                    action: "start",
                    interval_seconds: timelapseIntervalSeconds,
                    duration_seconds: timelapseDurationSeconds,
                };
                const response = await fetch(TIMELAPSE_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    const reason = data.error || "Failed to start timelapse";
                    throw new Error(reason);
                }
                applyTimelapseStatus(data);
            } catch (error) {
                console.error("Unable to start timelapse", error);
            } finally {
                timelapseRequestInFlight = false;
                updateTimelapseUI();
                scheduleTimelapseStatusPoll(2000);
            }
        }

        async function stopTimelapse() {
            if (!TIMELAPSE_URL || timelapseRequestInFlight) {
                return;
            }
            timelapseRequestInFlight = true;
            updateTimelapseUI();
            try {
                const response = await fetch(TIMELAPSE_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ action: "stop" }),
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok) {
                    const reason = data.error || "Failed to stop timelapse";
                    throw new Error(reason);
                }
                applyTimelapseStatus(data);
            } catch (error) {
                console.error("Unable to stop timelapse", error);
            } finally {
                timelapseRequestInFlight = false;
                updateTimelapseUI();
                scheduleTimelapseStatusPoll(6000);
            }
        }

        async function toggleTimelapse() {
            if (!TIMELAPSE_URL || timelapseRequestInFlight) {
                return;
            }
            timelapsePlannedCaptures = computePlannedTimelapseCaptures();
            if (timelapseActive) {
                await stopTimelapse();
            } else {
                await startTimelapse();
            }
        }

        async function fetchCaptureSettings() {
            if (!CAPTURE_SETTINGS_URL) {
                updateShootControlsUI();
                return;
            }
            try {
                const response = await fetch(CAPTURE_SETTINGS_URL);
                if (!response.ok) throw new Error("Failed to load capture settings");
                const data = await response.json();
                const normalizedMode = String(data.mode || "").toLowerCase();
                if (["single", "burst"].includes(normalizedMode)) {
                    shootMode = normalizedMode;
                }
                const parsedCount = Number(data.burst_count);
                if (!Number.isNaN(parsedCount) && parsedCount > 0) {
                    burstImageCount = parsedCount;
                }
                if (burstCountSelect) {
                    burstCountSelect.value = burstImageCount.toString();
                }
            } catch (error) {
                console.error("Unable to load capture settings", error);
            } finally {
                updateShootControlsUI();
            }
        }

        async function fetchActiveMode() {
            if (!UI_MODE_URL) {
                updateModeUI();
                return;
            }
            try {
                const response = await fetch(UI_MODE_URL);
                if (!response.ok) throw new Error("Failed to load UI mode");
                const data = await response.json();
                const normalizedMode = String(data.mode || MODE_AUTO).toLowerCase();
                activeMode = AVAILABLE_MODES.includes(normalizedMode) ? normalizedMode : MODE_AUTO;
            } catch (error) {
                console.error("Unable to load UI mode", error);
                activeMode = MODE_AUTO;
            } finally {
                if (activeMode !== MODE_AUTO) {
                    captureModeEnabled = false;
                }
                if (activeMode !== MODE_MANUAL) {
                    manualCaptureInFlight = false;
                }
                updateModeUI();
                scheduleTimelapseStatusPoll(activeMode === MODE_TIMELAPSE ? 0 : 8000);
            }
        }

        async function setActiveMode(nextMode) {
            const normalizedMode = String(nextMode || "").toLowerCase();
            if (!AVAILABLE_MODES.includes(normalizedMode) || normalizedMode === activeMode) {
                updateModeUI();
                return;
            }
            if (!UI_MODE_URL) {
                activeMode = normalizedMode;
                if (activeMode !== MODE_AUTO) {
                    captureModeEnabled = false;
                }
                if (activeMode !== MODE_MANUAL) {
                    manualCaptureInFlight = false;
                }
                updateModeUI();
                scheduleTimelapseStatusPoll(activeMode === MODE_TIMELAPSE ? 0 : 8000);
                return;
            }
            try {
                const response = await fetch(UI_MODE_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ mode: normalizedMode }),
                });
                if (!response.ok) throw new Error("Failed to set UI mode");
                const data = await response.json();
                const serverMode = String(data.mode || normalizedMode).toLowerCase();
                activeMode = AVAILABLE_MODES.includes(serverMode) ? serverMode : MODE_AUTO;
            } catch (error) {
                console.error("Unable to update UI mode", error);
                activeMode = MODE_AUTO;
            } finally {
                if (activeMode !== MODE_AUTO) {
                    captureModeEnabled = false;
                }
                if (activeMode !== MODE_MANUAL) {
                    manualCaptureInFlight = false;
                }
                updateModeUI();
                scheduleTimelapseStatusPoll(activeMode === MODE_TIMELAPSE ? 0 : 8000);
            }
        }

        async function triggerManualCapture() {
            if (activeMode !== MODE_MANUAL || manualCaptureInFlight || !MANUAL_CAPTURE_URL) {
                return;
            }
            manualCaptureInFlight = true;
            updateCaptureButtonUI();
            try {
                const payload = { mode: shootMode, burst_count: burstImageCount };
                const response = await fetch(MANUAL_CAPTURE_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                if (!response.ok) {
                    const errorDetails = await response.json().catch(() => ({}));
                    const reason = errorDetails.error || "Manual capture failed";
                    throw new Error(reason);
                }
            } catch (error) {
                console.error("Manual capture failed", error);
            } finally {
                manualCaptureInFlight = false;
                updateCaptureButtonUI();
            }
        }

        async function handleCaptureButtonInteraction(event) {
            event?.preventDefault();
            if (activeMode === MODE_TIMELAPSE) {
                await toggleTimelapse();
                return;
            }
            if (activeMode === MODE_AUTO) {
                await toggleCaptureMode();
                return;
            }
            await triggerManualCapture();
        }

        function setShootMode(mode) {
            if (!mode) return;
            const normalizedMode = String(mode).toLowerCase();
            if (shootMode === normalizedMode) return;
            shootMode = normalizedMode;
            updateShootControlsUI();
            void persistCaptureSettings({ mode: shootMode });
        }

        async function updateCaptureLabel(label) {
            if (!label) return;
            try {
                const response = await fetch(CAPTURE_LABEL_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ label }),
                });
                if (!response.ok) throw new Error("Failed to update capture label");
            } catch (error) {
                console.error("Unable to update capture label", error);
            }
        }

        async function loadLabels() {
            if (!captureSelect) return;
            captureSelect.innerHTML = "";
            try {
                const response = await fetch(LABELS_URL);
                const data = await response.json();
                const labels = data.labels || [];
                if (labels.length === 0) {
                    const option = document.createElement("option");
                    option.textContent = "No labels available";
                    option.disabled = true;
                    option.selected = true;
                    captureSelect.appendChild(option);
                    captureSelect.disabled = true;
                    return;
                }
                captureSelect.disabled = false;
                const normalizedDefaultLabel = DEFAULT_CAPTURE_LABEL.toLowerCase();
                let hasPreferredLabel = false;
                labels.forEach((label) => {
                    if (!label) return;
                    const option = document.createElement("option");
                    option.value = label;
                    option.textContent = label.charAt(0).toUpperCase() + label.slice(1);
                    if (!hasPreferredLabel && label.toLowerCase() === normalizedDefaultLabel) {
                        option.selected = true;
                        hasPreferredLabel = true;
                    }
                    captureSelect.appendChild(option);
                });
                if (!hasPreferredLabel && captureSelect.options.length > 0) {
                    captureSelect.options[0].selected = true;
                }
                if (captureSelect.value) {
                    await updateCaptureLabel(captureSelect.value);
                }
            } catch (error) {
                console.error("Unable to load labels", error);
                const option = document.createElement("option");
                option.textContent = "Labels unavailable";
                option.disabled = true;
                option.selected = true;
                captureSelect.appendChild(option);
                captureSelect.disabled = true;
            }
        }

        if (captureSelect) {
            captureSelect.addEventListener("change", (event) => {
                updateCaptureLabel(event.target.value);
            });
        }
        if (captureButton) {
            captureButton.addEventListener("click", handleCaptureButtonInteraction);
        }

        shootModeButtons.forEach((button) => {
            button.addEventListener("click", () => {
                setShootMode(button.dataset.shootMode);
            });
        });

        modeButtons.forEach((button) => {
            button.addEventListener("click", () => {
                void setActiveMode(button.dataset.uiMode);
            });
        });

        if (burstCountSelect) {
            burstCountSelect.addEventListener("change", (event) => {
                const parsedValue = Number(event.target.value);
                if (Number.isNaN(parsedValue)) {
                    return;
                }
                burstImageCount = parsedValue;
                void persistCaptureSettings({ burst_count: burstImageCount });
            });
        }

        if (timelapseIntervalSelect) {
            timelapseIntervalSelect.addEventListener("change", (event) => {
                const parsedValue = Number(event.target.value);
                if (Number.isNaN(parsedValue)) {
                    return;
                }
                timelapseIntervalSeconds = parsedValue;
                timelapsePlannedCaptures = computePlannedTimelapseCaptures();
                updateTimelapseUI();
            });
        }

        if (timelapseDurationSelect) {
            timelapseDurationSelect.addEventListener("change", (event) => {
                const parsedValue = Number(event.target.value);
                if (Number.isNaN(parsedValue)) {
                    return;
                }
                timelapseDurationSeconds = parsedValue;
                timelapsePlannedCaptures = computePlannedTimelapseCaptures();
                updateTimelapseUI();
            });
        }

        updateShootControlsUI();

        async function initializeCaptureUI() {
            await Promise.all([
                loadLabels(),
                fetchCaptureMode(),
                fetchCaptureSettings(),
                fetchActiveMode(),
                fetchTimelapseStatus(),
            ]);
            updateModeUI();
        }
        initializeCaptureUI();

        async function pollHealth() {
            const statusEl = document.getElementById("status");
            const statusIndicatorEl = document.getElementById("status-indicator");
            const statusContainerEl = document.getElementById("status-container");
            const streamPreviewEl = document.getElementById("stream-preview-img");
            const captureProgressEl = document.getElementById("capture-progress");
            try {
                const response = await fetch("/api/health");
                const data = await response.json();
                console.log("Health check", data);
                const status = data?.status || "disconnected";

                switch (status) {
                    case "ok":
                        statusContainerEl.classList.add("text-transparent");
                        statusContainerEl.classList.remove("text-ember")
                        streamPreviewEl.classList.remove("blur-md");
                        captureProgressEl.classList.add("hidden");
                        break;
                    case "capturing":
                        streamPreviewEl.classList.add("blur-md");
                        captureProgressEl.classList.remove("hidden");
                        break;
                    case "connecting":
                        statusContainerEl.classList.remove("text-transparent");
                        statusEl.textContent = "Waiting for Camera...";
                        statusContainerEl.classList.add("text-ember");
                        streamPreviewEl.classList.add("blur-md");
                        captureProgressEl.classList.add("hidden");
                        break;
                    default:
                        statusContainerEl.classList.remove("hidden");
                        statusEl.textContent = "Waiting for Camera...";
                        break;
                }
            } catch (error) {
                console.error("Health check failed", error);
            } finally {
                setTimeout(pollHealth, 1000);
            }
        }
        pollHealth();
    </script>
</body>

</html>